\section{Архитектура и модули системы} % (fold)
\label{sec:arch_and_mod}

\subsection{Основные компоненты симулятора}
\label{sub:arch_and_mod:modules}

Для симуляции динамической оперативной памяти был выбран симулятор DRAMSim2. Данный симулятор обладает рядом преимуществ: простота, независимость от сторонних библиотек, хорошо организованная внутренняя архитектура программы. 

Симулятор является потактовым, вследствие чего все основные классы унаследованы от единого базового класса SimulatorObject. В листинге~\ref{lst:arch_and_mod:modules:simulator_object} представлена его структура. Объект этого класса имеет единственное поле - счетчик currentClockCycle, который инкрементируется методом step. Таким образом все компоненты симулятора работают в единой временной плоскости. Метод update каждый производный класс имплементирует по-своему, вкладывая нужную ему функциональность.  

\begin{lstlisting}[style=cplusplusstyle, caption={Класс SimulatorObject}, label=lst:arch_and_mod:modules:simulator_object]
class SimulatorObject
{
public:
  uint64_t currentClockCycle;

  void step();
  virtual void update()=0;
};
\end{lstlisting}

Самыми важными компонентами симулятора являются классы MemorySystem, MemoryController и DRAMDevice. 
Класс MemorySystem является ядром симулятора, включающим в себя всю его функциональность. Класс имеет простой интерфейс, через который внешний драйвер взаимодействует с памятью. С помощью метода AddTransaction драйвер добавляет запрос в память. Метод Update нужно вызывать в конце каждого цикла. Отсчет циклов производит драйвер памяти. 

Класс MemoryController  накапливает запросы от драйвера в очереди транзакций, транслируя их затем в команды для устройства памяти.  
Сама память представлена классом DRAMDevice, включающим в себя классы Rank и Bank. В зависимости от конфигурации каждый Rank содержит в себе определенное количество объектов Bank. В классе Bank матрица ячеек памяти представлена картой, где номер ряда является ключом, а значение представляет собой вектор слов, чьи порядковые номера соответствуют колонкам ячеек. Класс Bank представлен в листинге~\ref{lst:arch_and_mod:modules:bank}.

\begin{lstlisting}[style=cplusplusstyle, caption={Класс Bank}, label=lst:arch_and_mod:modules:bank]
class Bank
    {
    public:
        Bank();
        ~Bank();

        void read(BusPacket *busPacket);
        void write(const BusPacket *busPacket);

    public:
        BankState currentState;

    private:
        typedef map<uint64_t, std::auto_ptr<std::vector<uint16_t>> > row_map;
        row_map rowEntries;
    };
\end{lstlisting}

Для данного симулятора в открытом доступе имеется версия с возможностью хранения данных, что значительно ускорило разработку программного средства. Симулируемая память является слово-ориентированной. По этой причине появилась необходимость добавления функциональности для записи конкретных бит, а не только слов, в ячейки памяти. В листинге~\ref{lst:arch_and_mod:modules:write_bit}. представлен метод writeBit, который записывает 0 или 1 (в зависимости от параметра set) в позицию bit в ячейке по адресу заданного ряда и колонки.

\begin{lstlisting}[style=cplusplusstyle, caption={Метод записи конкретных бит в слове}, label=lst:arch_and_mod:modules:write_bit]
void Bank::writeBit(int row, int col, int bit, bool set)
{
    auto row_ = rowEntries[row].get();

    if (set)
        (*row_)[col] |= 1 << bit;
    else
    {
        if ((*row_)[col] & (1 << bit))
            (*row_)[col] ^= 1 << bit;
    }
}
\end{lstlisting}

В целом работа всей системы представляет собой следующее: контроллер памяти накапливает в очереди транзакций запросы от драйвера; на каждом новом цикле работы системы контроллер памяти извлекает одну транзакцию из очереди, транслирует её адрес в значения номера ранка, банка, ряда и колонки ячейки памяти, преобразует пакет транзакции в команду для устройства памяти и помещает этот пакет в очередь команд; из очереди команд по одному пакету в цикл извлекается команда и контроллер памяти определяет, какое действие нужно совершить устройству памяти. Решение  зависит от множества факторов: состояния банков (например, команда чтения не может быть выполнена, если адресуемая ячейка не активна, в этом случае нужна предварительная команда Activate); контроллер регенерации, который может приостановить все транзакции в системе и запустить процесс обновления памяти. Каждую команду записи в память отслеживает адаптивный сигнатурный анализатор, о котором будет рассказано в следующих подразделах. Контроллер регенерации с помощью сигнатурного анализатора выясняет, были ли неполадки в памяти за время её работы, и при необходимости запускает тесты. Внутри самого ОЗУ находится контроллер неисправностей, который имитирует поведение ячеек с физическими неисправностями, а также контролирует процесс разрядки ячеек при длительном отсутствии команды Refresh. ОЗУ в свою очередь в ответ на команды чтения возвращает контроллеру памяти считанные данные, которые сохраняются в очереди пакетов чтения и затем отправляются драйверу. Основные модули системы представлены на рисунке~\ref{fig:arch_and_mod:modules:main_modules}.

\begin{figure}[ht]
\centering
  \includegraphics[scale=0.55]{a_main_modules.png}  
  \caption{ Основные компоненты симулятора ОЗУ. }
  \label{fig:arch_and_mod:modules:main_modules}
\end{figure}

\subsection{Симуляция процесса деградации памяти}
\label{sub:arch_and_mod:memory_discharge}

Источником ошибок может является свойство конденсаторов памяти разряжаться. Это происходит в случаях, когда период обновления памяти сдвинут и ячейки успевают терять свой заряд.

Этот процесс симулирует класс Discharger, который следит за периодами обновления памяти, и если такой период не наступил вовремя, то начинается постепенная деградация отдельных бит памяти в случайных местах (биты теряют свои данные и хранят 0). 

Для генерации случайных адресов ячеек и позиций бит в них используется класс uniform\_int\_distribution стандартной библиотеки шаблонов языка C++. 
Он генерирует случайные числа в диапазоне [a,b], подчинённые дискретному равномерному распределению, которое представлено на формуле~\ref{eq:arch_and_mod:memory_discharge:uniform_func} следующей функцией распределения:

\begin{equation}
  \label{eq:arch_and_mod:memory_discharge:uniform_func}
  P(i|a,b) = \frac{1}
           {b-a+1}, a \le i \ge b
\end{equation}

Плотность распределения показана на рисунке~\ref{fig:arch_and_mod:modules:uniform_distribution}.

\begin{figure}[ht]
\centering
  \includegraphics[scale=1]{a_uniform_distribution.png}  
  \caption{ Плотность распределения дискретного равномерного распределения. }
  \label{fig:arch_and_mod:modules:uniform_distribution}
\end{figure}

В зависимости от того, сколько циклов прошло с момента, когда должен был начаться процесс обновления памяти, количество генерируемых адресов, а следовательно количество бит, обращающихся в 0, возрастает по формуле:

\begin{equation}
  \label{eq:arch_and_mod:memory_discharge:e_func}
  f(t) = e^{\frac{\sqrt{t}}
           {5.2}}
\end{equation}

По умолчанию период обновления памяти $T_{refresh}$ = 2600 циклов. 1 цикл равен 3 нсек. Таким образом каждые 7800 нсек память должна обновляться. В итоге в соответствии с формулой примерно через 2000 циклов(с учетом погрешности генератора адресов, т.к. один и тот же адрес может сгенерироваться несколько раз) все ячейки обернутся в 0, если соответствующий процесс регенерации памяти так и не был запущен. График функции представлен на рисунке ~\ref{fig:arch_and_mod:memory_discharge:efunc_grafic}.

\begin{figure}[ht]
\centering
  \includegraphics[scale=0.75]{a_efunc.png}  
  \caption{ График экспоненциальной функции ~\ref{eq:arch_and_mod:memory_discharge:e_func} }
  \label{fig:arch_and_mod:memory_discharge:efunc_grafic}
\end{figure}

\subsection{Симуляция процесса регенерации памяти}
\label{sub:arch_and_mod:memory_refresh}

Заряд конденсатора динамического ОЗУ со временем уменьшается вследствие утечки, поэтому для сохранения содержимого памяти процесс регенерации каждой ячейки памяти должен производится через определенное время. На время регенерации взаимодействие ОЗУ с внешними устройствами(драйвером) должно быть приостановлено, т.е. путем перевода этих устройств в режим ожидания.

В первую очередь необходимо выяснить, произошли ли ошибки во время работы памяти. Наиболее экономичным по временным затратам и эффективным методом является алгоритм адаптивного сжатия выходных данных (АСВД) (Self-Adjusting Output Data Compression - SAODC). Подробно данная технология рассмотрена в работах \cite{SAODC_Ivaniuk} и ~\cite{SAODC_Yarmolik}. Данный подход позволяет полностью избежать временных издержек для вычисления эталонной сигнатуры. Согласно этой концепции эталонная характеристика (сигнатура) $S_{ref}$ начального содержимого бит-ориентированного ОЗУ вычисляется как сумма по модулю два всех адресов ячеек, содержащих значение 1. Пример вычисления $S_{ref}$ для ОЗУ с 8 ячейками представлен на рисунке~\ref{fig:arch_and_mod:memory_refresh:saodc}.

\begin{figure}[ht]
\centering
  \includegraphics[scale=0.75]{a_saodc.png}  
  \caption{ Вычисление эталонной сигнатуры для бит-ориентированного ОЗУ.}
  \label{fig:arch_and_mod:memory_refresh:saodc}
\end{figure}

При таком методе изменения в памяти не потребуют заново вычислять эталонную сигнатуру, достаточно просто сложить по модулю два адрес изменившейся ячейки со значением эталонной сигнатуры. Обновление сигнатуры выглядит следующим образом:

\begin{equation}
  \label{eq:arch_and_mod:memory_refresh:adjusting_signature}
  S_{ref}^{new} = S_{ref}^{old} \oplus a \cdot ( M[a]^{new} \oplus M[a]^{old} ) \text{\,,}
\end{equation}
\begin{explanation}
где & $ a $ & адрес изменившейся ячейки; \\
    & $ M[a]^{new} $ & новое значение ячейки; \\
    & $ M[a]^{old} $ & старое значение ячейки.
\end{explanation}

У рассмотренного сигнатурного анализатора имеется достаточно полезное свойство. Сумма по модулю два всех адресов ячеек, содержащих 1, равна сумме по модулю два всех адресов ячеек, содержащих 0. Это свойство широко применяется в неразрушающих маршевых тестах для анализа содержимого ОЗУ. 

Для слово-ориентированного ОЗУ применяется та же схема сжатия данных, но потребуются некоторые дополнительные действия. Пусть имеется память с матрицей ячеек 16 на 16. Т.е. 16 рядов и 16 колонок. Каждая ячейка имеет объём 8 бит. Применяя метод АСА (адаптивный сигнатурный анализатор), теперь нужно оперировать адресами не ячеек, а бит памяти. Таким образом для 5-го бита в ячейке, расположенной на 4-ом ряду и 2-ой колонке адрес будет представлен числом  0x215 в шестнадцатиричной системе счисления, или числом 0100 0010 101 в двоичной. Построение адреса бита пояснено на рисунке ~\ref{fig:arch_and_mod:memory_refresh:address}.

\begin{figure}[ht]
\centering
  \includegraphics[scale=0.4]{a_address.png}  
  \caption{ Представление адреса бита в слово-ориентированном ОЗУ.}
  \label{fig:arch_and_mod:memory_refresh:address}
\end{figure}

После каждой операции записи в память, эталонная сигнатура обновляется. При наступлении периода регенерации, высчитывается тестовая сигнатура $S_{test}$ и затем сравнивается с эталонной $S_{ref}$. Если сигнатуры совпали - значит с памятью всё в порядке, в противном случае произошли ошибки. При однократной ошибке достаточно просто найти ядрес ячейки и позицию бита, в котором произошла ошибка. Сложение двух сигнатур  $S_{test} \oplus S_{ref}$ дает адрес бита с изменившимися данными. Таким образом процедура регенерации памяти состоит из следующих шагов:
\begin{enumerate}
  \item При наступлении периода обновления памяти вычисляется тестовая сигнатура и сравнивается с эталонной;
  \item Если сигнатуры не совпали, то предполагаем, что произошла однократная ошибка. Инвертируется бит по адресу $S_{test} \oplus S_{ref}$;
  \item Повторяется шаг а;
  \item Если сигнатуры совпали, то была однократная ошибка, которую удалось устранить. В противном случае переход к шагу д;
  \item Запуск неразрушающего маршевого теста для выявления неисправностей;
  \item Если тест ничего не обнаружил, значит была многократная ошибка, в противном случае неисправность, которую нужно диагностировать.
\end{enumerate}

Блок-схема алгоритма регенерации памяти представлена на рисунке ~\ref{fig:arch_and_mod:memory_refresh:refresh_chart}.

\begin{figure}[ht]
\centering
  \includegraphics[scale=0.70]{a_refresh_chart.png}  
  \caption{ Схема алгоритма регенерации памяти ОЗУ.}
  \label{fig:arch_and_mod:memory_refresh:refresh_chart}
\end{figure}

За регенерацию памяти отвечает класс RegenerationController. Класс SAODCController обеспечивает вычисление рабочей и эталонной сигнатур. Метод обновления эталонной сигнатуры при каждой операции чтения представлен в листинге ~\ref{lst:arch_and_mod:memory_refresh:update_sig}

\begin{lstlisting}[style=cplusplusstyle, caption={Обновление эталонной сигнатуры ОЗУ}, label=lst:arch_and_mod:memory_refresh:update_sig]
void SAODCController::UpdateRef(BusPacket* packet)
{
    if (packet->busPacketType == DATA)
    {
        uint16_t oldData = dramDevice->read(packet->rank, packet->bank,
                                            packet->row, packet->column);
        uint16_t newData = packet->data->getData();
        if (oldData != newData)
        {
            int address = GetAddress(rank, bank, row, col, data);
            RefSignature ^= address;       
        }
    }
}

int SAODCController::GetAddress(int rank, int bank, int row, int col, uint16_t data)
{
    //get sum of changed bits
    int bitSum = 0;
    int bitCount  = 0; // count of bit, that stores '1'
    for (int i = 0; (unsigned)i < DEVICE_WIDTH; i++)
    {
        if (data & (1 << i))
        {
            bitSum ^= i;
            bitCount++;
        }
    }    
    if (bitCount % 2 == 0)
    {
        rank = bank = row = col = 0;
    }
    return translator.TranslateToAddr(rank, bank, row, col, bitSum);
}
\end{lstlisting} 

\subsection{Представление маршевых тестов}
\label{sub:arch_and_mod:march_tests}

Для выявления неисправностей ОЗУ решено использовать маршевые тесты из-за их простоты и эффективности. Все маршевые тесты построены по единому принципу и различаются лишь набором элементов. Поэтому целесообразно представить такие тесты с помощью обобщенной структуры, которая может подстроиться под любой тест. Направление перебора адресов отражается элементами MD\_UP, MD\_DOWN и MD\_BOTH перечисления MarchDirection. Операции чтения и записи так же представлены элементами перечисления MarchOperation. Элементы MO\_RD и MO\_RDC обозначают операцию чтения прямого и обратного значения в буфер из ячейки памяти, элементы MO\_WD и MO\_WDC описывают операции записи прямого и обратного значения из буфера в ячейку памяти. Фаза маршевого теста отражена в структуре MarchPhase, представленной в листинге ~\ref{lst:arch_and_mod:march_tests:march_phase}.

\begin{lstlisting}[style=cplusplusstyle, caption={Структура фазы маршевого теста}, label=lst:arch_and_mod:march_tests:march_phase]
struct MarchPhase
{
    MarchDirection direction;
    std::vector<MarchOperation> elements;
};
\end{lstlisting} 

Таким образом маршевый тест представляется вектором, содержащим определённое количество структур MarchPhase. Инициализация вектора элементов маршевого теста March C представлена в листинге ~\ref{lst:arch_and_mod:march_tests:march_init}.

\begin{lstlisting}[style=cplusplusstyle, caption={Инициализация вектора элементов маршевого теста March C}, label=lst:arch_and_mod:march_tests:march_init]
void InitializeTest()
{
    std::vector<MarchPhase> phases;
    phases.push_back({ MD_UP, { MO_RD, MO_WDC } });
    phases.push_back({ MD_UP, { MO_RDC, MO_WD } });
    phases.push_back({ MD_DOWN, { MO_RD, MO_WDC } });
    phases.push_back({ MD_DOWN, { MO_RDC, MO_WD } });
    phases.push_back({ MD_DOWN, { MO_RD } });
};
\end{lstlisting} 

Другие виды маршевых тестов инициализируются подобным образом.

Логика создания и выполнения маршевых тестов находится в классе MarchTestController. Запуск теста производит класс RegenerationController. Для сжатия данных используется адаптивный сигнатурный анализатор, рассмотренный в предыдущем пункте. На этапе инициализации теста в качестве эталонной сигнатуры берётся уже вычисленная ранее рабочая сигнатура класса RegenerationController. Далее на каждой фазе маршевого теста вычисляется тестовая сигнатура и в конце фазы сравнивается с эталонной. При правильном функционировании памяти сигнатуры должны всегда совпадать вне зависимости от операций, производимых элементами маршевого теста. Это происходит потому, что маршевый тест является неразрушающим, а также благодаря свойству АСА, которое заключается в равенстве сумм адресов ячеек, содержащих 1, и адресов ячеек, содержащих 0. Выполнение маршевого теста занимает определённое время, а потому выполнение отдельных его фаз разбито на несколько циклов работы симулятора. Выполнение теста приводится в листинге ~\ref{lst:arch_and_mod:march_tests:march_run}.

\begin{lstlisting}[style=cplusplusstyle, caption={Функция выполнения маршевого теста}, label=lst:arch_and_mod:march_tests:march_run]
void MarchTestController::Update()
{
    if (!state.testStarted) return;

    saodc.ClearTestSig();
    MarchPhase& phase = phases[state.phase];
    int addrStart = 0;
    int counter = 0;
    int bottom = 0;
    int top = NUM_BANKS * NUM_COLS * NUM_ROWS - 1;

    if (phase.direction == MD_UP || phase.direction == MD_BOTH)
    {
        addrStart = bottom;
        counter = 1;
    }
    else if (phase.direction == MD_DOWN)
    {
        addrStart = top;
        counter = -1;
    }
    for (int addr = addrStart; addr >= bottom && addr <= top; addr += counter)
    {
        uint16_t buffer = 0;
        for (auto& el : phase.elements)
        {
            RunElement(el, addr, buffer);
        }
    }
    int err = saodc.Compare();
    if (err)
    {
        state.testPassed = false;
        cout << "[MarchTest] Errors are detected while running phase! Signature sum is " << err << "(" << addrTranslator.GetDescription(err, true) << ")" << endl;
    }
    state.phase++;
    if (state.phase == phases.size())
    {
        state.testCompleted = true;
        state.testStarted = false;
    }
}
\end{lstlisting} 

Выполнение каждой отдельной операции маршевого элемента приведено в листинге ~\ref{lst:arch_and_mod:march_tests:march_element_run}.

\begin{lstlisting}[style=cplusplusstyle, caption={Выполнение элемента маршевого теста}, label=lst:arch_and_mod:march_tests:march_element_run]
void MarchTestController::RunElement(int element, int address, uint16_t &buffer)
{
    int r = 0, b = 0, row = 0, col = 0;
    addrTranslator.Translate(address, r, b, row, col);
    uint16_t data = 0;
    switch (element)
    {
    case MO_RD:
        data = dramDevice->read(r, b, row, col);
        buffer = data;
        break;
    case MO_RDC:
        data = dramDevice->read(r, b, row, col);
        buffer = ~data;
        break;
    case MO_WD:
        dramDevice->write(r, b, row, col, buffer);
        break;
    case MO_WDC:
        dramDevice->write(r, b, row, col, ~buffer);
        break;
    }
    //convertData
    if (element == MO_RD || element == MO_RDC)
    {
        saodc.UpdateTestSig(r, b, row, col, data);
    }
}
\end{lstlisting} 

\subsection{Моделирование функциональных неисправностей ОЗУ}
\label{sub:arch_and_mod:faults}

Для моделирования функциональных неисправностей ОЗУ используется обобщенная структура Fault, представленная в листинге~\ref{lst:arch_and_mod:faults:faults_struct}. 
\begin{lstlisting}[style=cplusplusstyle, caption={Структура описания функциональной неисправности ОЗУ}, label=lst:arch_and_mod:faults:faults_struct]
struct Fault
{
    FaultType type;
    uint16_t victimVal;
    uint16_t agressorVal;
    int agressorAddr;
};
\end{lstlisting} 

Поле type может принимать одно из следующих значений: SAF,TF, CFin, CFid, CFst. Они объединены в перечислении FaultType. Поле victimVal для разных моделей неисправностей имеет различное значение, но обобщенно оно хранит значение ячейки-жертвы. Так для неисправностей типа SAF victimVal будет содержать значение ячейки памяти, которое эта ячейка хранит постоянно и изменить его не может. Для неисправности TF это поле хранит значение, перейдя в которое ячейка превращается в константную, т.е. не может поменять своё состояние. Для неисправностей CFid и CFst данное поле хранит значение, в которое зависимая ячейка принудительно переходит (для CFid) или в которое она может перейти только при определённом значении в ячейке-агрессоре (для CFst). Для неисправностей типа CFin данное поле не неиспользуется. 

Поле agressorAddr хранит адрес ячейки-агрессора. Это поле используется в неисправностях типа CF, как и поле agressorVal. Поле agressorVal хранит значение ячейки-агрессора, при котором зависимая ячейка может перейти в состояние victimVal (для CFst) или значение, при переходе в которое, ячейка-жертва насильно меняет своё значение на victimVal (для CFin и CFid). 

Класс, контролирующий поведение ячеек в соответствии с различными моделями неисправностей, называется FaultController и находится в классе DRAMDevice. При каждой операции записи в память FaultController вмешивается в работу системы и имитирует поведение неисправностей. Все основные виды неисправностей выявляются на протяжении работы симулятора, однако при неисправностях типа SAF необходимо инициализировать значения ячеек памяти на старте симулятора. 

Метод, анализирующий операцию записи в ячейку памяти и принимающий решение о выполнении тех или иных действий, соответствующих моделям неисправностей, представлен в листинге~\ref{lst:arch_and_mod:faults:faults_run}.

\begin{lstlisting}[style=cplusplusstyle, caption={Реализаия поведения ячеек при функциональных неисправностях}, label=lst:arch_and_mod:faults:faults_run]
void FaultController::DoFaults(int r, int b, int row, int col, uint16_t data)
{
  uint16_t oldData = dramDevice->read(r, b, row, col);
  uint16_t bitMask = oldData ^ data;
  
  for (unsigned i = 0; i < DEVICE_WIDTH; i++)
  {
    if (bitMask & (1 << i))
    {
      int addr = translator.TranslateToAddr(r, b, row, col, i);
      DoOperationOnBit(addr, data & (1 << i), oldData & (1 << i));
    }
  }
}

void FaultController::DoOperationOnBit(int addr, uint16_t newVal, uint16_t oldVal)
{
  int r = 0, b = 0, row = 0, col = 0, bit = 0;
  translator.Translate(addr, r, b, row, col, bit);
  
  if (IsFaulty(addr))
  {
    auto fault = faultyCells[addr];
    switch (fault.type)
    {
    case SAF: break;//set on init   
    case TF:
    {
           if (oldVal != fault.victimVal)
           {
             (*dramDevice->ranks)[r].banks[b].writeBit(row, col, bit, newVal == 1);
           }
           break;
    }
    case CFin:
    {
           (*dramDevice->ranks)[r].banks[b].writeBit(row, col, bit, newVal == 1);
             break;
    }     
    case CFid:
    {
           (*dramDevice->ranks)[r].banks[b].writeBit(row, col, bit, newVal == 1); 
           break;
    }
    case CFst:
    {
           if (newVal != fault.victimVal)
             (*dramDevice->ranks)[r].banks[b].writeBit(row, col, bit, newVal == 1);
           else
           {
             int r_ = 0, b_ = 0, row_ = 0, col_ = 0, bit_ = 0;
             translator.Translate(fault.agressorAddr, r_, b_, row_, col_, bit_);
             uint16_t aggressorData = (*dramDevice->ranks)[r_].banks[b_].read(row_, col_);
             if ((aggressorData & (1 << bit_)) == fault.agressorVal)
               (*dramDevice->ranks)[r].banks[b].writeBit(row, col, bit, newVal == 1);
           }
           break;
    }
    default: break;
    }
  }
  else
  {
    if (IsAgressor(addr))
    {
      Fault fault;
      int victim = 0;
      GetAgressorAttributes(addr, victim, fault);
      switch (fault.type)
      {
      case CFin:
      {
             if (newVal == fault.agressorVal && newVal != oldVal)
             {
               int r_=0, b_=0, row_=0, col_=0, bit_=0;
               translator.Translate(victim, r_, b_, row_, col_, bit_);
               (*dramDevice->ranks)[r_].banks[b_].invertBit(row_, col_, bit_);
             }
             break;
      }
      case CFid:
      {
             if (newVal == fault.agressorVal && newVal != oldVal)
             {
               int r_ = 0, b_ = 0, row_ = 0, col_ = 0, bit_ = 0;
               translator.Translate(victim, r_, b_, row_, col_, bit_);
               (*dramDevice->ranks)[r_].banks[b_].writeBit(row_, col_, bit_, fault.agressorVal == 1);
             }
             break;
      }
      default :
        break;
      }
      (*dramDevice->ranks)[r].banks[b].writeBit(row, col, bit, newVal == 1);
    }
    else
    {
      (*dramDevice->ranks)[r].banks[b].writeBit(row, col, bit, newVal == 1);
    }
  } 
}
\end{lstlisting} 




